#!/usr/bin/env node
import { Command } from "commander";
import fs from "fs";
import path from "path";
import { promisify } from "util";
import readline from "readline";

const readlineInterface = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

const question = promisify(readlineInterface.question).bind(readlineInterface);

const program = new Command();

program
  .name("index-sketches")
  .description(
    "Create index.js files that exports a map of all sketches in a directory"
  )
  .argument("[dir]", "directory to process", ".")
  .option("-r, --recursive", "process directories recursively")
  .option("-y, --yes", "skip confirmation and overwrite files")
  .option("-a, --array", "default export as array instead of map")
  .option("-s, --star", "use import * as syntax instead of default imports")
  .parse();

const opts = program.opts();
const dir = program.args[0] || ".";

async function shouldContinue(file) {
  const answer = await question(
    `File ${file} already exists. Overwrite? (y/n) `
  );
  return answer.toLowerCase() === "y";
}

function kebabToCamel(name) {
  return name.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
}

async function processDirectory(dir) {
  const files = fs.readdirSync(dir).filter((file) => {
    const ext = path.extname(file).toLowerCase();
    return (
      (ext === ".js" || ext === ".jsx" || ext === ".mdx") && file !== "index.js"
    );
  });

  if (files.length === 0) return false;

  const indexPath = path.join(dir, "index.js");
  if (fs.existsSync(indexPath) && !opts.yes) {
    const proceed = await shouldContinue(indexPath);
    if (!proceed) return false;
  }

  const imports = files
    .map((file) => {
      const name = path.basename(file, path.extname(file));
      return opts.star
        ? `import * as ${kebabToCamel(name)} from './${file}';`
        : `import ${kebabToCamel(name)} from './${file}';`;
    })
    .join("\n");

  let exportStatement;
  if (opts.array) {
    const exportList = files
      .map((file) => kebabToCamel(path.basename(file, path.extname(file))))
      .join(", ");
    exportStatement = `[${exportList}]`;
  } else {
    const exportMap = files
      .map((file) => {
        const origName = path.basename(file, path.extname(file));
        const camelName = kebabToCamel(origName);
        return `  "${origName}": ${camelName}`;
      })
      .join(",\n");
    exportStatement = `{\n${exportMap}\n}`;
  }

  const indexContent = `// generated by bin/module-indexer.js
${imports}

export default ${exportStatement};
`;

  fs.writeFileSync(indexPath, indexContent);
  console.log(`Created index.js in ${dir}`);
  return true;
}

async function processRecursive(dir) {
  await processDirectory(dir);

  const items = fs.readdirSync(dir, { withFileTypes: true });
  for (const item of items) {
    if (item.isDirectory()) {
      await processRecursive(path.join(dir, item.name));
    }
  }
}

(async () => {
  if (opts.recursive) {
    await processRecursive(dir);
  } else {
    await processDirectory(dir);
  }
  readlineInterface.close();
})();
